// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: topic.sql

package dbr

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const decrTagsById = `-- name: DecrTagsById :exec
UPDATE p_tag
SET quote_num = quote_num-1,
	modified_on=$1
WHERE id = ANY($2::bigserial[])
`

type DecrTagsByIdParams struct {
	ModifiedOn int32
	Ids        pgtype.Array[int64]
}

func (q *Queries) DecrTagsById(ctx context.Context, arg *DecrTagsByIdParams) error {
	_, err := q.db.Exec(ctx, decrTagsById, arg.ModifiedOn, arg.Ids)
	return err
}

const hotTags = `-- name: HotTags :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE  is_del = false AND quote_num > 0
ORDER BY quote_num DESC
OFFSET $1 LIMIT $2
`

type HotTagsParams struct {
	Offset int32
	Limit  int32
}

type HotTagsRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) HotTags(ctx context.Context, arg *HotTagsParams) ([]*HotTagsRow, error) {
	rows, err := q.db.Query(ctx, hotTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HotTagsRow
	for rows.Next() {
		var i HotTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrTagsById = `-- name: IncrTagsById :exec
UPDATE p_tag
SET quote_num = quote_num+1, modified_on = $1
WHERE id = ANY($2::bigserial[])
`

type IncrTagsByIdParams struct {
	ModifiedOn int32
	Ids        pgtype.Array[int64]
}

func (q *Queries) IncrTagsById(ctx context.Context, arg *IncrTagsByIdParams) error {
	_, err := q.db.Exec(ctx, incrTagsById, arg.ModifiedOn, arg.Ids)
	return err
}

const insertTags = `-- name: InsertTags :one
INSERT INTO p_tag (user_id, tag, created_on, modified_on, quote_num)
VALUES ($1, $2, $3, $3, 1)
RETURNING id, user_id, tag, quote_num
`

type InsertTagsParams struct {
	UserID    int64
	Tag       string
	CreatedOn int32
}

type InsertTagsRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) InsertTags(ctx context.Context, arg *InsertTagsParams) (*InsertTagsRow, error) {
	row := q.db.QueryRow(ctx, insertTags, arg.UserID, arg.Tag, arg.CreatedOn)
	var i InsertTagsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tag,
		&i.QuoteNum,
	)
	return &i, err
}

const newestTags = `-- name: NewestTags :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE is_del = false AND quote_num > 0
ORDER BY id DESC
OFFSET $1 LIMIT $2
`

type NewestTagsParams struct {
	Offset int32
	Limit  int32
}

type NewestTagsRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) NewestTags(ctx context.Context, arg *NewestTagsParams) ([]*NewestTagsRow, error) {
	rows, err := q.db.Query(ctx, newestTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*NewestTagsRow
	for rows.Next() {
		var i NewestTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByIdA = `-- name: TagsByIdA :many
SELECT id
FROM p_tag
WHERE id = ANY($1::bigserial[]) AND is_del = false AND quote_num >= 0
`

func (q *Queries) TagsByIdA(ctx context.Context, ids pgtype.Array[int64]) ([]int64, error) {
	rows, err := q.db.Query(ctx, tagsByIdA, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByIdB = `-- name: TagsByIdB :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE id = ANY($1::bigserial[])
`

type TagsByIdBRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByIdB(ctx context.Context, ids pgtype.Array[int64]) ([]*TagsByIdBRow, error) {
	rows, err := q.db.Query(ctx, tagsByIdB, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByIdBRow
	for rows.Next() {
		var i TagsByIdBRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByKeywordA = `-- name: TagsByKeywordA :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE is_del AND quote_num > 0
ORDER BY quote_num DESC
OFFSET 0 LIMIT 6
`

type TagsByKeywordARow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByKeywordA(ctx context.Context) ([]*TagsByKeywordARow, error) {
	rows, err := q.db.Query(ctx, tagsByKeywordA)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByKeywordARow
	for rows.Next() {
		var i TagsByKeywordARow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByKeywordB = `-- name: TagsByKeywordB :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE is_del = false AND tag LIKE $1
ORDER BY quote_num DESC
OFFSET 0 LIMIT 6
`

type TagsByKeywordBRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByKeywordB(ctx context.Context, tag string) ([]*TagsByKeywordBRow, error) {
	rows, err := q.db.Query(ctx, tagsByKeywordB, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByKeywordBRow
	for rows.Next() {
		var i TagsByKeywordBRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByName = `-- name: TagsByName :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE tag = ANY($1::varchar[]) AND is_del = false AND quote_num >= 0
`

type TagsByNameRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByName(ctx context.Context, tags pgtype.Array[string]) ([]*TagsByNameRow, error) {
	rows, err := q.db.Query(ctx, tagsByName, tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByNameRow
	for rows.Next() {
		var i TagsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
